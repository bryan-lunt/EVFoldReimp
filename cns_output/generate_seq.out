          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3
           Status: General release
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: hostname unknown (Mac/Intel,64-bit)
                               with  2 threads
           Program started by: lunt
           Program started at: 18:54:55 on 11-Jul-2012
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>{+ file: generate_seq.inp +} 
 CNSsolve>{+ directory: general +} 
 CNSsolve>{+ description: Generate structure file for protein, dna/rna, water, 
 CNSsolve>                ligands and/or carbohydrate from sequence information only +} 
 CNSsolve>{+ comment: modified by Brian Smith (Edinburgh University) to allow protein 
 CNSsolve>            residue renumbering +} 
 CNSsolve>{+ authors: Paul Adams, and Axel Brunger +} 
 CNSsolve>{+ copyright: Yale University +} 
 CNSsolve> 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file -} 
 CNSsolve> 
 CNSsolve>{- Special patches will have to be entered manually at the relevant points 
 CNSsolve>   in the file - see comments throughout the file -} 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE>{============ protein topology, linkage, and parameter files =============} 
 DEFINE> 
 DEFINE>{* topology files *} 
 DEFINE>{===>} topology_infile_1="CNS_TOPPAR:protein-allhdg5-4.top"; 
 DEFINE>{===>} topology_infile_2="CNS_TOPPAR:dna-rna-allatom-hj-opls.top"; 
 DEFINE>{===>} topology_infile_3=""; 
 DEFINE>{===>} topology_infile_4=""; 
 DEFINE>{===>} topology_infile_5=""; 
 DEFINE>{===>} topology_infile_6=""; 
 DEFINE>{===>} topology_infile_7=""; 
 DEFINE>{===>} topology_infile_8=""; 
 DEFINE> 
 DEFINE>{* linkage files for linear, continuous polymers (protein, DNA, RNA) *} 
 DEFINE>{===>} link_infile_1="CNS_TOPPAR:protein-allhdg5-4.link"; 
 DEFINE>{===>} link_infile_2="CNS_TOPPAR:dna-rna-pho.link"; 
 DEFINE>{===>} link_infile_3=""; 
 DEFINE> 
 DEFINE>{* parameter files *} 
 DEFINE>{===>} parameter_infile_1="CNS_TOPPAR:protein-allhdg5-4.param"; 
 DEFINE>{===>} parameter_infile_2="CNS_TOPPAR:dna-rna-allatom-hj-opls.param"; 
 DEFINE>{===>} parameter_infile_3=""; 
 DEFINE>{===>} parameter_infile_4=""; 
 DEFINE>{===>} parameter_infile_5=""; 
 DEFINE>{===>} parameter_infile_6=""; 
 DEFINE>{===>} parameter_infile_7=""; 
 DEFINE>{===>} parameter_infile_8=""; 
 DEFINE> 
 DEFINE>{====================== other linkages and modifications  ==================} 
 DEFINE> 
 DEFINE>{* extra linkages and modifications by custom patches *} 
 DEFINE>{===>} patch_infile=""; 
 DEFINE> 
 DEFINE>{============================= sequence files ==============================} 
 DEFINE> 
 DEFINE>{* multiple sequence files of the same type can be defined by duplicating 
 DEFINE>   the entries below and incrementing the file number *} 
 DEFINE> 
 DEFINE>{* protein sequence file 1 *} 
 DEFINE>{===>} prot_sequence_infile_1="my.seq"; 
 DEFINE>{* segid *} 
 DEFINE>{===>} prot_segid_1="A"; 
 DEFINE>{* start residue numbering at *} 
 DEFINE>{===>} renumber_1=1; 
 DEFINE> 
 DEFINE>{============================= output files ================================} 
 DEFINE> 
 DEFINE>{* output structure file *} 
 DEFINE>{===>} structure_outfile="my.mtf"; 
 DEFINE> 
 DEFINE>{=========================== disulphide bonds ==============================} 
 DEFINE> 
 DEFINE>{* Select pairs of cysteine residues that form disulphide bonds *} 
 DEFINE>{* First 2 entries are the segid and resid of the first cysteine (CYS A). *} 
 DEFINE>{* Second 2 entries are the segid and resid of the second cysteine (CYS B). *} 
 DEFINE>{+ table: rows=8 numbered 
 DEFINE>   cols=5 "use" "segid CYS A" "resid CYS A" "segid CYS B" "resid CYS B" +} 
 DEFINE> 
 DEFINE>{========================= generate parameters =============================} 
 DEFINE> 
 DEFINE>{* hydrogen flag - determines whether hydrogens will be retained *} 
 DEFINE>{* must be true for NMR, atomic resolution X-ray crystallography 
 DEFINE>   or modelling.  Set to false for most X-ray crystallographic 
 DEFINE>   applications at resolution > 1A *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} hydrogen_flag=true; 
 DEFINE> 
 DEFINE>{* set bfactor flag *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} set_bfactor=true; 
 DEFINE> 
 DEFINE>{* set bfactor value *} 
 DEFINE>{===>} bfactor=15.0; 
 DEFINE> 
 DEFINE>{* set occupancy flag *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} set_occupancy=true; 
 DEFINE> 
 DEFINE>{* set occupancy value *} 
 DEFINE>{===>} occupancy=1.0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{===========================================================================} 
 DEFINE>{         things below this line do not need to be changed unless           } 
 DEFINE>{         you need to apply patches - at the appropriate places marked      } 
 DEFINE>{===========================================================================} 
 DEFINE> 
 DEFINE> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve> checkversion 1.3 
 Program version= 1.3 File version= 1.3
 CNSsolve> 
 CNSsolve> evaluate ($log_level=quiet) 
 Assuming literal string "QUIET"
 EVALUATE: symbol $LOG_LEVEL set to "QUIET" (string)
 CNSsolve> 
 CNSsolve> {- read parameter files -} 
 CNSsolve> parameter 
 PARRDR>  evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 PARRDR>  evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>         @@&parameter_infile_$counter 
 ASSFIL: file protein-allhdg5-4.param opened.
 PARRDR>remarks file toppar/protein-allhdg5-4.param 
 PARRDR>remark 
 PARRDR>remark   for file protein-allhdg-ucl.top  version UCL  date 14-MAR-00 
 PARRDR>remark   for file protein-allhdg-dih-ucl.top  version UCL  date 07-JUL-01 
 PARRDR>remark   Geometric energy function parameters for distance geometry and 
 PARRDR>remark   simulated annealing. 
 PARRDR>remark   Original author: Michael Nilges, EMBL Heidelberg 
 PARRDR>remark   Modifications: Mark A. Williams, UCL London 
 PARRDR>remark   Several modifications for HADDOCK: Alexandre Bonvin, Utrecht Uni 
 PARRDR>remark   Last modification 8-19-2011 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>         @@&parameter_infile_$counter 
 ASSFIL: file dna-rna-allatom-hj-opls.param opened.
 PARRDR>remarks file toppar/dna-rna-allatom.top 
 PARRDR>remarks  all-hydrogen dna/rna parameters using the OPLS force field 
 PARRDR> 
 PARRDR>!RNA PARAMETER FILE 'FRAMEWORK' FROM PARALLHDG.DNA AND ATOM NAMES 
 PARRDR>! AND HEAVY ATOM PARAMETERS FROM DNA-RNA.PARAM 
 PARRDR>!INCLUDES ALL NONEXCHANGEABLE HYDROGEN TERMS FOR BOND, ANGLE, AND 
 PARRDR>!IMPROPERS WITH ENERGY CONSTANT VARIABLES: $kchbond, $kchangle, AND $kchimpr. 
 PARRDR>!BOND, ANGLE, AND IMPROPERS WERE ESTIMATED FROM VALUES FROM THE STANDARD 
 PARRDR>!NUCLEOTIDES OF INSIGHTII 95.0 (BIOSYM/MOLECULAR SIMULATIONS). 
 PARRDR>!CREATED 2/24/96 -- JASON P. RIFE AND PETER B. MOORE 
 PARRDR>!ADDED OPLSX SECTION 6/2/07 -- HENRY JONKER 
 PARRDR>! DNA-RNA-ALLATOM.PARAM 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    7.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    8.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    9.00000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    10.0000     (real)
 PARRDR>  end loop read 
 PARRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 PARRDR>   if ( &exist_parameter_infile_$counter = true ) then 
 PARRDR>      if ( &BLANK%parameter_infile_$counter = false ) then 
 PARRDR>         @@&parameter_infile_$counter 
 PARRDR>      end if 
 PARRDR>   else 
 PARRDR>    evaluate ($done=true) 
 PARRDR>   end if 
 PARRDR>   evaluate ($counter=$counter+1) 
 PARRDR>  end loop read 
 PARRDR> end 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 CNSsolve> 
 CNSsolve> {- read topology files -} 
 CNSsolve> topology 
 RTFRDR>  evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 RTFRDR>  evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>         @@&topology_infile_$counter 
 ASSFIL: file protein-allhdg5-4.top opened.
 RTFRDR>remarks file toppar/protein-allhdg5-4.top 
 RTFRDR>remarks 
 RTFRDR>remarks   file topallhdg.pro  version 5.4  date 07-July-10 
 RTFRDR>remarks      for file parallhdg.pro version 5.4 date 07-July-10 or later 
 RTFRDR>remarks   Geometric energy function parameters for distance geometry and 
 RTFRDR>remarks      simulated annealing. 
 RTFRDR>remarks   Author: Michael Nilges, EMBL Heidelberg; Institut Pasteur, Paris 
 RTFRDR>remarks   This file contains modifications from M. Williams, UCL London 
 RTFRDR>remarks   and multiple modifications for HADDOCK from A. Bonvin, Utrecht University 
 RTFRDR>remarks   Last modification 10-01-2012 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR> 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>         @@&topology_infile_$counter 
 ASSFIL: file dna-rna-allatom-hj-opls.top opened.
 RTFRDR>remarks file toppar/dna-rna-allatom-hj-opls.top 
 RTFRDR>remarks  all-hydrogen dna/rna topology using the OPLS force field 
 RTFRDR> 
 RTFRDR>!RNA TOPOLOGY FILE 'FRAMEWORK' FROM TOPALLHDG.DNA AND ATOM NAMES 
 RTFRDR>!  FROM DNA-RNA.PARAM 
 RTFRDR>!INCLUDES ALL NONEXCHANGEABLE HYDROGENS AND TERMS FOR BOND, ANGLE, AND 
 RTFRDR>!IMPROPERS. NONEXCHANGEABLE HYDROGEN CHARGES WERE ASSIGNED 0.035. 
 RTFRDR>!CARBON CHARGES WERE REDUCED 0.035 FOR EACH ATTACHED HYDROGEN. 
 RTFRDR>!CREATED 2/24/96-- JASON P. RIFE AND PETER B. MOORE 
 RTFRDR>!CHANGED TO OPLSX CHARGES 6/2/07 -- HENRY JONKER 
 RTFRDR>! DNA-RNA-ALLATOM.TOP 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR> 
 RTFRDR> 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    3.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    4.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    5.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    6.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    7.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    8.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    9.00000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as true
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    10.0000     (real)
 RTFRDR>  end loop read 
 RTFRDR>  while ( $done = false ) loop read 
 NEXTCD: condition evaluated as false
 RTFRDR>   if ( &exist_topology_infile_$counter = true ) then 
 RTFRDR>      if ( &BLANK%topology_infile_$counter = false ) then 
 RTFRDR>         @@&topology_infile_$counter 
 RTFRDR>      end if 
 RTFRDR>   else 
 RTFRDR>     evaluate ($done=true) 
 RTFRDR>   end if 
 RTFRDR>   evaluate ($counter=$counter+1) 
 RTFRDR>  end loop read 
 RTFRDR> end 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop prot 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_prot_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     if ( &BLANK%prot_sequence_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>       do (refx=0) (all) 
 SELRPN:      0 atoms have been selected out of      0
 CNSsolve>       segment 
 SEGMENT>         chain 
 CHAIN>           evaluate ($count=1) 
 EVALUATE: symbol $COUNT set to    1.00000     (real)
 CHAIN>           evaluate ($done2=false) 
 EVALUATE: symbol $DONE2 set to FALSE (logical)
 CHAIN>           while ( $done2 = false ) loop read 
 NEXTCD: condition evaluated as true
 CHAIN>             if ( &exist_link_infile_$count = true ) then 
 NEXTCD: condition evaluated as true
 CHAIN>               if ( &BLANK%link_infile_$count = false ) then 
 NEXTCD: condition evaluated as true
 CHAIN>                  @@&link_infile_$count 
 ASSFIL: file protein-allhdg5-4.link opened.
 CHAIN>remarks file toppar/protein-allhdg5-4.link 
 CHAIN>remarks 
 CHAIN>remarks this is a macro to define standard protein peptide bonds 
 CHAIN>remarks and termini to generate a protein sequence. 
 CHAIN> 
 CHAIN>!added links for MSE (8-19-2011, ATB) 
 CHAIN> 
 CHAIN>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 CHAIN>set message=off echo=off end 
 CHAIN> 
 CHAIN>               end if 
 CHAIN>             else 
 CHAIN>               evaluate ($done2=true) 
 CHAIN>             end if 
 CHAIN>             evaluate ($count=$count+1) 
 EVALUATE: symbol $COUNT set to    2.00000     (real)
 CHAIN>           end loop read 
 CHAIN>           while ( $done2 = false ) loop read 
 NEXTCD: condition evaluated as true
 CHAIN>             if ( &exist_link_infile_$count = true ) then 
 NEXTCD: condition evaluated as true
 CHAIN>               if ( &BLANK%link_infile_$count = false ) then 
 NEXTCD: condition evaluated as true
 CHAIN>                  @@&link_infile_$count 
 ASSFIL: file dna-rna-pho.link opened.
 CHAIN>remarks  file toppar/dna-rna-pho.link 
 CHAIN>remarks  macro to define nucleic acid links and terminii 
 CHAIN>remarks  this file uses a 5' phosphate group 
 CHAIN>remarks 
 CHAIN> 
 CHAIN>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 CHAIN>set message=off echo=off end 
 CHAIN> 
 CHAIN>               end if 
 CHAIN>             else 
 CHAIN>               evaluate ($done2=true) 
 CHAIN>             end if 
 CHAIN>             evaluate ($count=$count+1) 
 EVALUATE: symbol $COUNT set to    3.00000     (real)
 CHAIN>           end loop read 
 CHAIN>           while ( $done2 = false ) loop read 
 NEXTCD: condition evaluated as true
 CHAIN>             if ( &exist_link_infile_$count = true ) then 
 NEXTCD: condition evaluated as true
 CHAIN>               if ( &BLANK%link_infile_$count = false ) then 
 NEXTCD: condition evaluated as false
 CHAIN>                  @@&link_infile_$count 
 CHAIN>               end if 
 CHAIN>             else 
 CHAIN>               evaluate ($done2=true) 
 CHAIN>             end if 
 CHAIN>             evaluate ($count=$count+1) 
 EVALUATE: symbol $COUNT set to    4.00000     (real)
 CHAIN>           end loop read 
 CHAIN>           while ( $done2 = false ) loop read 
 NEXTCD: condition evaluated as true
 CHAIN>             if ( &exist_link_infile_$count = true ) then 
 NEXTCD: condition evaluated as false
 CHAIN>               if ( &BLANK%link_infile_$count = false ) then 
 CHAIN>                  @@&link_infile_$count 
 CHAIN>               end if 
 CHAIN>             else 
 CHAIN>               evaluate ($done2=true) 
 EVALUATE: symbol $DONE2 set to TRUE (logical)
 CHAIN>             end if 
 CHAIN>             evaluate ($count=$count+1) 
 EVALUATE: symbol $COUNT set to    5.00000     (real)
 CHAIN>           end loop read 
 CHAIN>           while ( $done2 = false ) loop read 
 NEXTCD: condition evaluated as false
 CHAIN>             if ( &exist_link_infile_$count = true ) then 
 CHAIN>               if ( &BLANK%link_infile_$count = false ) then 
 CHAIN>                  @@&link_infile_$count 
 CHAIN>               end if 
 CHAIN>             else 
 CHAIN>               evaluate ($done2=true) 
 CHAIN>             end if 
 CHAIN>             evaluate ($count=$count+1) 
 CHAIN>           end loop read 
 CHAIN>           sequence @@&prot_sequence_infile_$counter end 
 ASSFIL: file my.seq opened.
 SEQUENCE>MET ILE LYS ASP ILE THR ILE GLY GLN TYR ILE PRO GLY ASN SER PHE VAL HIS LYS LEU ASP PRO ARG VAL LYS ILE ILE ILE SER LEU ILE TYR ILE ILE ASP LEU PHE ILE VAL ASN ASN PHE LYS GLY TYR ILE PHE ILE VAL LEU PHE THR LEU ALA ALA ILE LEU ILE SER GLN ILE LYS PHE LYS TYR ILE 
 SEQUence-element (terminate with END) = end 
 SEGMNT:    66 residues were inserted into segment "    "
 CHAIN>         end 
 SEGMENT>       end 
 Status of internal molecular topology database:
 -> NATOM=       1141(MAXA=     1000000)  NBOND=       1153(MAXB=     1000000)
 -> NTHETA=      2107(MAXT=     2000000)  NGRP=          68(MAXGRP=   1000000)
 -> NPHI=        1680(MAXP=     2000000)  NIMPHI=       598(MAXIMP=   1000000)
 -> NNB=          990(MAXNB=    1000000) 
 CNSsolve>       do (segid="T^" + encode($counter)) (attr refx=9999) 
 SELRPN:   1141 atoms have been selected out of   1141
 CNSsolve>     end if 
 CNSsolve>     if ( &exist_renumber_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>         if ( &BLANK%renumber_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>           evaluate ($segid="T^" + encode($counter)) 
 EVALUATE: symbol $SEGID set to "T^1" (string)
 CNSsolve>           do ( resid = adjustl(format("I4",decode(resid) + &renumber_$counter - 1))) 
 SELRPN>              ( (attr refx=9999) and segid $segid ) 
 SELRPN:   1141 atoms have been selected out of   1141
 CNSsolve>         end if 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop prot 
 CNSsolve> while ( $done = false ) loop prot 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_prot_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%prot_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           evaluate ($count=1) 
 CNSsolve>           evaluate ($done2=false) 
 CNSsolve>           while ( $done2 = false ) loop read 
 CNSsolve>             if ( &exist_link_infile_$count = true ) then 
 CNSsolve>               if ( &BLANK%link_infile_$count = false ) then 
 CNSsolve>                  @@&link_infile_$count 
 CNSsolve>               end if 
 CNSsolve>             else 
 CNSsolve>               evaluate ($done2=true) 
 CNSsolve>             end if 
 CNSsolve>             evaluate ($count=$count+1) 
 CNSsolve>           end loop read 
 CNSsolve>           sequence @@&prot_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid="T^" + encode($counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     if ( &exist_renumber_$counter = true ) then 
 CNSsolve>         if ( &BLANK%renumber_$counter = false ) then 
 CNSsolve>           evaluate ($segid="T^" + encode($counter)) 
 CNSsolve>           do ( resid = adjustl(format("I4",decode(resid) + &renumber_$counter - 1))) 
 CNSsolve>              ( (attr refx=9999) and segid $segid ) 
 CNSsolve>         end if 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop prot 
 CNSsolve> while ( $done = false ) loop prot 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_prot_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%prot_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           evaluate ($count=1) 
 CNSsolve>           evaluate ($done2=false) 
 CNSsolve>           while ( $done2 = false ) loop read 
 CNSsolve>             if ( &exist_link_infile_$count = true ) then 
 CNSsolve>               if ( &BLANK%link_infile_$count = false ) then 
 CNSsolve>                  @@&link_infile_$count 
 CNSsolve>               end if 
 CNSsolve>             else 
 CNSsolve>               evaluate ($done2=true) 
 CNSsolve>             end if 
 CNSsolve>             evaluate ($count=$count+1) 
 CNSsolve>           end loop read 
 CNSsolve>           sequence @@&prot_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid="T^" + encode($counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     if ( &exist_renumber_$counter = true ) then 
 CNSsolve>         if ( &BLANK%renumber_$counter = false ) then 
 CNSsolve>           evaluate ($segid="T^" + encode($counter)) 
 CNSsolve>           do ( resid = adjustl(format("I4",decode(resid) + &renumber_$counter - 1))) 
 CNSsolve>              ( (attr refx=9999) and segid $segid ) 
 CNSsolve>         end if 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop prot 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop nseg 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_prot_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     if ( &BLANK%prot_sequence_infile_$counter = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>       evaluate ($segtmp="T^" + encode($counter)) 
 EVALUATE: symbol $SEGTMP set to "T^1" (string)
 CNSsolve>       do (segid=capitalize(&prot_segid_$counter)) (segid $segtmp) 
 SELRPN:   1141 atoms have been selected out of   1141
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 EVALUATE: symbol $COUNTER set to    2.00000     (real)
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop nseg 
 CNSsolve> while ( $done = false ) loop nseg 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_prot_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%prot_sequence_infile_$counter = false ) then 
 CNSsolve>       evaluate ($segtmp="T^" + encode($counter)) 
 CNSsolve>       do (segid=capitalize(&prot_segid_$counter)) (segid $segtmp) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop nseg 
 CNSsolve> while ( $done = false ) loop nseg 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_prot_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%prot_sequence_infile_$counter = false ) then 
 CNSsolve>       evaluate ($segtmp="T^" + encode($counter)) 
 CNSsolve>       do (segid=capitalize(&prot_segid_$counter)) (segid $segtmp) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop nseg 
 CNSsolve> 
 CNSsolve> evaluate ($ssc=1) 
 EVALUATE: symbol $SSC set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop ssbr 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_ss_use_$ssc = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &ss_use_$ssc = true ) then 
 CNSsolve>       evaluate ($segidtmp1=capitalize(&ss_i_segid_$ssc)) 
 CNSsolve>       evaluate ($segidtmp2=capitalize(&ss_j_segid_$ssc)) 
 CNSsolve>       patch disu 
 CNSsolve>         reference=1=(segid $QUOTE%segidtmp1 and resid &ss_i_resid_$ssc) 
 CNSsolve>         reference=2=(segid $QUOTE%segidtmp2 and resid &ss_j_resid_$ssc) 
 CNSsolve>       end 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($ssc=$ssc+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop ssbr 
 CNSsolve> while ( $done = false ) loop ssbr 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_ss_use_$ssc = true ) then 
 CNSsolve>     if ( &ss_use_$ssc = true ) then 
 CNSsolve>       evaluate ($segidtmp1=capitalize(&ss_i_segid_$ssc)) 
 CNSsolve>       evaluate ($segidtmp2=capitalize(&ss_j_segid_$ssc)) 
 CNSsolve>       patch disu 
 CNSsolve>         reference=1=(segid $QUOTE%segidtmp1 and resid &ss_i_resid_$ssc) 
 CNSsolve>         reference=2=(segid $QUOTE%segidtmp2 and resid &ss_j_resid_$ssc) 
 CNSsolve>       end 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($ssc=$ssc+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop ssbr 
 CNSsolve> 
 CNSsolve> {* any special protein patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop nucl 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_nucl_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%nucl_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           evaluate ($count=1) 
 CNSsolve>           evaluate ($done2=false) 
 CNSsolve>           while ( $done2 = false ) loop read 
 CNSsolve>             if ( &exist_link_infile_$count = true ) then 
 CNSsolve>               if ( &BLANK%link_infile_$count = false ) then 
 CNSsolve>                  @@&link_infile_$count 
 CNSsolve>               end if 
 CNSsolve>             else 
 CNSsolve>               evaluate ($done2=true) 
 CNSsolve>             end if 
 CNSsolve>             evaluate ($count=$count+1) 
 CNSsolve>           end loop read 
 CNSsolve>           sequence @@&nucl_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&nucl_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop nucl 
 CNSsolve> while ( $done = false ) loop nucl 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_nucl_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%nucl_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           evaluate ($count=1) 
 CNSsolve>           evaluate ($done2=false) 
 CNSsolve>           while ( $done2 = false ) loop read 
 CNSsolve>             if ( &exist_link_infile_$count = true ) then 
 CNSsolve>               if ( &BLANK%link_infile_$count = false ) then 
 CNSsolve>                  @@&link_infile_$count 
 CNSsolve>               end if 
 CNSsolve>             else 
 CNSsolve>               evaluate ($done2=true) 
 CNSsolve>             end if 
 CNSsolve>             evaluate ($count=$count+1) 
 CNSsolve>           end loop read 
 CNSsolve>           sequence @@&nucl_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&nucl_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop nucl 
 CNSsolve> 
 CNSsolve> {* patch rna sugars to dna here if needed - select the residues *} 
 CNSsolve> {===>} 
 CNSsolve> for $resid in () loop dna 
 CNSsolve>   patch deox reference=nil=(resid $resid) end 
 CNSsolve> end loop dna 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> {* any special nucleic acid patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop carbo 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_carbo_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%carbo_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&carbo_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&carbo_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop carbo 
 CNSsolve> while ( $done = false ) loop carbo 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_carbo_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%carbo_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&carbo_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&carbo_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop carbo 
 CNSsolve> 
 CNSsolve> evaluate ($carc=1) 
 EVALUATE: symbol $CARC set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop cabr 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_carbo_use_$carc = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &carbo_use_$carc = true ) then 
 CNSsolve>       evaluate ($segidtmp1=capitalize(&carbo_i_segid_$carc)) 
 CNSsolve>       evaluate ($segidtmp2=capitalize(&carbo_j_segid_$carc)) 
 CNSsolve>       patch &carbo_patch_$carc 
 CNSsolve>         reference=-=(segid $QUOTE%segidtmp1 and 
 CNSsolve>                      resid &carbo_i_resid_$carc) 
 CNSsolve>         reference=+=(segid $QUOTE%segidtmp2 and 
 CNSsolve>                      resid &carbo_j_resid_$carc) 
 CNSsolve>       end 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($carc=$carc+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop cabr 
 CNSsolve> while ( $done = false ) loop cabr 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_carbo_use_$carc = true ) then 
 CNSsolve>     if ( &carbo_use_$carc = true ) then 
 CNSsolve>       evaluate ($segidtmp1=capitalize(&carbo_i_segid_$carc)) 
 CNSsolve>       evaluate ($segidtmp2=capitalize(&carbo_j_segid_$carc)) 
 CNSsolve>       patch &carbo_patch_$carc 
 CNSsolve>         reference=-=(segid $QUOTE%segidtmp1 and 
 CNSsolve>                      resid &carbo_i_resid_$carc) 
 CNSsolve>         reference=+=(segid $QUOTE%segidtmp2 and 
 CNSsolve>                      resid &carbo_j_resid_$carc) 
 CNSsolve>       end 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($carc=$carc+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop cabr 
 CNSsolve> 
 CNSsolve> {* any special carbohydrate patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop prost 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_prost_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%prost_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&prost_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&prost_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop prost 
 CNSsolve> while ( $done = false ) loop prost 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_prost_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%prost_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&prost_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&prost_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop prost 
 CNSsolve> 
 CNSsolve> {* any special prosthetic group patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop liga 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_lig_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%lig_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&lig_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&lig_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop liga 
 CNSsolve> while ( $done = false ) loop liga 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_lig_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%lig_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&lig_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&lig_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop liga 
 CNSsolve> 
 CNSsolve> {* any special ligand patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop ion 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_ion_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%ion_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&ion_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&ion_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop ion 
 CNSsolve> while ( $done = false ) loop ion 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_ion_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%ion_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&ion_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&ion_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop ion 
 CNSsolve> 
 CNSsolve> {* any special ion patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve> evaluate ($done=false) 
 EVALUATE: symbol $DONE set to FALSE (logical)
 CNSsolve> while ( $done = false ) loop water 
 NEXTCD: condition evaluated as true
 CNSsolve>   if ( &exist_water_sequence_infile_$counter = true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ( &BLANK%water_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&water_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&water_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 EVALUATE: symbol $DONE set to TRUE (logical)
 CNSsolve>   end if 
 CNSsolve> end loop water 
 CNSsolve> while ( $done = false ) loop water 
 NEXTCD: condition evaluated as false
 CNSsolve>   if ( &exist_water_sequence_infile_$counter = true ) then 
 CNSsolve>     if ( &BLANK%water_sequence_infile_$counter = false ) then 
 CNSsolve>       do (refx=0) (all) 
 CNSsolve>       segment 
 CNSsolve>         chain 
 CNSsolve>           sequence @@&water_sequence_infile_$counter end 
 CNSsolve>         end 
 CNSsolve>       end 
 CNSsolve>       do (segid=capitalize(&water_segid_$counter)) (attr refx=9999) 
 CNSsolve>     end if 
 CNSsolve>     evaluate ($counter=$counter+1) 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve> end loop water 
 CNSsolve> 
 CNSsolve> {* any special water patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> {* any final patches can be applied here *} 
 CNSsolve> {===>} 
 CNSsolve> {<===} 
 CNSsolve> 
 CNSsolve> if (&hydrogen_flag=false) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   delete selection=( hydrogen ) end 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> if (&set_bfactor=true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   do (b=&bfactor) ( all ) 
 SELRPN:   1141 atoms have been selected out of   1141
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> if (&set_occupancy=true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   do (q=&occupancy) ( all ) 
 SELRPN:   1141 atoms have been selected out of   1141
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> write structure output=&structure_outfile end 
 ASSFIL: file my.mtf opened.
 CNSsolve> 
 CNSsolve> stop 
          ============================================================
           Maximum dynamic memory allocation:     8263248 bytes
           Maximum dynamic memory overhead:           288 bytes
           Program started at: 18:54:55 on 11-Jul-2012
           Program stopped at: 18:54:55 on 11-Jul-2012
           CPU time used:       0.2266 seconds
          ============================================================
